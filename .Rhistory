tinytex::install_tinytex()
# Load the necessary packages required to reproduce the report. For example:
library(kableExtra)
library(magrittr)
# Load the library packages to run the below r codes
library(readxl)
library(dplyr)
library(tidyr)
library(Hmisc)
library(forecast)
library(editrules)
library(formatR)
# Add your names, numbers and percentage of your contribution here.
na<- c("Vasitha Tilakumara","Vandana Durgaprasad Guthula")
no<- c("s4033457","s4011068")
pc<- c("50%","50%")
s<- data.frame(cbind(na,no,pc))
colnames(s)<- c("Student name", "Student number", "Percentage of contribution")
s %>% kbl(caption = "Group information") %>%
kable_classic(full_width = F, html_font = "Cambria")
# Import the data, provide your R codes here.
health_data <- read_xlsx("Health_Nutrition_and_Population_Statistics.xlsx")
development_data <- read_xlsx("World_Development_Indicators.xlsx")
# Number of 'NA' values in each row in the data frames
na_row_h<-apply(X = is.na(health_data), MARGIN = 1, FUN = sum)
na_row_d<-apply(X = is.na(development_data), MARGIN = 1, FUN = sum)
# get rid of the rows which contains all the variables 'NA'
health_data <- health_data[which(na_row_h < 10),]
development_data <- development_data[which(na_row_d < 9),]
health_data$`2013 [YR2013]` <- as.numeric(health_data$`2013 [YR2013]`)
health_data$`2018 [YR2018]` <- as.numeric(health_data$`2018 [YR2018]`)
health_data$`2020 [YR2020]` <- as.numeric(health_data$`2020 [YR2020]`)
health_data$`2021 [YR2021]` <- as.numeric(health_data$`2021 [YR2021]`)
health_data$`2022 [YR2022]` <- as.numeric(health_data$`2022 [YR2022]`)
# Following data transformation obtain a partial tidy version of the data sets imported
health_data_tidy <-pivot_longer(health_data[,c(-4)],names_to = "year", values_to = "value", cols = 4:9)
health_data_tidy <- health_data_tidy %>% pivot_wider(names_from = "Series Name", values_from = "value")
# appply kable styling for head() function to display the tidied data frame
kable(head(health_data_tidy)[,1:4], caption = "health_data_tidy data frame columns[1:4]") %>%
kable_styling(bootstrap_options = c("hover", "condensed"),full_width = TRUE)
kable(head(health_data_tidy)[,5:8], caption = "health_data_tidy data frame columns[5:8]") %>%
kable_styling(bootstrap_options = c("hover", "condensed"),full_width = TRUE)
kable(head(health_data_tidy)[,9:12], caption = "health_data_tidy data frame columns[9:12]") %>%
kable_styling(bootstrap_options = c("hover", "condensed"),full_width = TRUE)
development_data_tidy <-pivot_longer(development_data[,c(-4)],names_to = "year", values_to = "value", cols = 4:8)
development_data_tidy <-development_data_tidy %>% pivot_wider(names_from = "Series Name", values_from = "value")
# appply kable styling for head() function to display the tidied data frame
kable(head(development_data_tidy)[,1:4], caption = "development_data_tidy data frame columns[1:4]") %>%
kable_styling(bootstrap_options = c("hover", "condensed"),full_width = TRUE)
kable(head(development_data_tidy)[,5:8], caption = "development_data_tidy data frame columns[5:8]") %>%
kable_styling(bootstrap_options = c("hover", "condensed"),full_width = TRUE)
kable(head(development_data_tidy)[,9:12], caption = "development_data_tidy data frame columns[9:12]") %>%
kable_styling(bootstrap_options = c("hover", "condensed"),full_width = TRUE)
# After partially tidying the data two data sets are joined based on the Country Name and the Country Code
merged_data <- health_data_tidy %>% left_join(development_data_tidy,by=c("Country Name","Country Code","year"))
# data structure of the data frame
class(merged_data)
# Dimensions of the datasets
dim(merged_data)
# Display structure of the datasets
str(merged_data)
# Print the summary table using kable and kable_styling
kable(summary(merged_data)[,1:12], caption = "Summary of the merged data frame PART I") %>%
kable_styling(bootstrap_options = c("hover", "condensed"),full_width = TRUE)
kable(summary(merged_data)[,13:21], caption = "Summary of the merged data frame PART II") %>%
kable_styling(bootstrap_options = c("hover", "condensed"),full_width = TRUE)
# Convert all the character type variables into factors
merged_data <- data.frame(lapply(merged_data[,names(merged_data)
%in% c("Country Name","year")],
function(x) if (is.character(x)) {as.factor(x)} else {x}),
lapply(merged_data[,!names(merged_data)
%in% c("Country Name","Country Code","year", "NA.x", "NA.y",
"Population ages 0-14, total",
"Population ages 15-64, total",
"Population ages 65 and above, total")],
function(x) if (is.character(x)) {as.numeric(x)} else {x}),
lapply(merged_data[,names(merged_data)
%in% c("Population ages 0-14, total",
"Population ages 15-64, total",
"Population ages 65 and above, total")],
function(x) if (is.character(x)) {as.integer(x)} else {x}))
# check the levels of the main factor variables used in the analysis
levels(merged_data$Country.Name)
levels(merged_data$year)
# Next, levels arranges and ordered
merged_data$Country.Name <- factor(merged_data$Country.Name,
levels = c("Australia","China","India","Japan",
"Malaysia","New Zealand","Russian Federation",
"Singapore","Sri Lanka","Thailand",
"United Arab Emirates","United Kingdom",
"United States","Vietnam"))
merged_data$year <- factor(merged_data$year,
levels = c("2013 [YR2013]","2018 [YR2018]","2019 [YR2019]","2020 [YR2020]","2021 [YR2021]","2022 [YR2022]"),
labels = c("2013","2018","2019","2020","2021","2022"))
# check the levels of the main factor variables after arranging and labelling
levels(merged_data$Country.Name)
levels(merged_data$year)
# Subset the merged data set to get the variables used for the analysis
merged_data <- merged_data[,!names(merged_data) %in% c("Adolescent.fertility.rate..births.per.1.000.women.ages.15.19.",
"Current.health.expenditure.per.capita..current.US..",
"Cause.of.death..by.injury....of.total.", "Cause.of.death..by.communicable.diseases.and.maternal..prenatal.and.nutrition.conditions....of.total.",
"Cause.of.death..by.non.communicable.diseases....of.total.",
"Access.to.clean.fuels.and.technologies.for.cooking..rural....of.rural.population.",
"Access.to.clean.fuels.and.technologies.for.cooking..urban....of.urban.population." ,
"Access.to.electricity..rural....of.rural.population.",
"Access.to.electricity..urban....of.urban.population.")]
# Display merged_data data frame after subseting
kable(head(merged_data)[,1:5], caption = "merged_data data frame columns[1:5]") %>%
kable_styling(bootstrap_options = c("hover", "condensed"),full_width = TRUE)
kable(head(merged_data)[,6:9], caption = "merged_data data frame columns[5:10]") %>%
kable_styling(bootstrap_options = c("hover", "condensed"),full_width = TRUE)
merged_data$Population <- merged_data$Population.ages.0.14..total +
merged_data$Population.ages.15.64..total +
merged_data$Population.ages.65.and.above..total
tidy_data <- data.frame(Country_name = merged_data$Country.Name,
Year = merged_data$year,
Birth_rate = merged_data$Birth.rate..crude..per.1.000.people.,
CHE = merged_data$Current.health.expenditure....of.GDP.,
Death_rate = merged_data$Death.rate..crude..per.1.000.people.,
ANNI_PC = merged_data$Adjusted.net.national.income.per.capita..annual...growth.,
Total_population = merged_data$Population)
head(tidy_data)
# calculate the number of missing values in each row
num_missing_row<-apply(X = is.na(tidy_data), MARGIN = 1, FUN = sum)
# Dimensions of the data set
dimension<- dim(tidy_data)
# get rid of each row having 80% or more NA values
tidy_data <- tidy_data[which(num_missing_row < (dimension[2]*(80/100))),]
# check the number of missing value in each variable
tidy_data %>%  sapply(function(x) length(which(is.na(x))))
# median imputation (for numerical variables)
tidy_data$Birth_rate <- impute(tidy_data$Birth_rate, fun = median)
tidy_data$CHE <- impute(tidy_data$CHE, fun = median)
tidy_data$Death_rate <- impute(tidy_data$Death_rate, fun = median)
tidy_data$ANNI_PC <- impute(tidy_data$ANNI_PC, fun = median)
# mean imputation (for numerical variables)
tidy_data$Total_population <- impute(tidy_data$Total_population, fun = mean)
# check the number of missing value in each variable
tidy_data %>%  sapply(function(x) length(which(is.na(x))))
# Checking for any infinite values in the data frame
sum(sapply(tidy_data,is.infinite))
# checking for any Nan values (meaning “not a number”)
sum(sapply(tidy_data,is.nan))
# checking for obvious error based on the rules specfied
# defining all the rule for all the variables in the data set
Rules <- editset(c("Total_population>0",
"Birth_rate>0",
"CHE>0",
"Death_rate>0",
"Country_name %in% c(\"Australia\",\"China\",\"India\",\"Japan\",\"Malaysia\",
\"New Zealand\",\"Russian Federation\",\"Singapore\",
\"Sri Lanka\",\"Thailand\",\"United Arab Emirates\",
\"United Kingdom\",\"United States\",\"Vietnam\")",
"Year %in% c(\"2013\",\"2018\",\"2019\",\"2020\",\"2021\",\"2022\")"))
# Set of all the rules defined
Rules
# Data set is checked against all the defined rules
Violated<-violatedEdits(Rules, tidy_data)
# sum of violation of all the rules defined above
sum(Violated)
# summary of the all the rule violations
summary(Violated)
# checking the outliers in all the numericl variables using boxplot
tidy_data$Birth_rate %>%  boxplot(main="Birth Rate", ylab="Birth Rate,crude (per 1,000 people)", col = "grey")
tidy_data$CHE %>%  boxplot(main="Current health expenditure (% of GDP)", ylab="Percentage of GDP", col = "grey")
tidy_data$Death_rate %>%  boxplot(main="Death Rate", ylab="Death rate, crude (per 1,000 people)", col = "grey")
tidy_data$ANNI_PC %>%  boxplot(main="Adjusted net national income per capita (annual % growth)", ylab="Annual Percentage Growth", col = "grey")
tidy_data$Total_population %>%  boxplot(main="Total_population", ylab="Total_population", col = "grey")
# function is define to handle outliers in the Salary variable
cap <- function(x){
quantiles <- quantile( x, c(.05, 0.25, 0.75, .95 ))
x[ x < quantiles[2] - 1.5*IQR(x) ] <- quantiles[1]
x[ x > quantiles[3] + 1.5*IQR(x) ] <- quantiles[4]
x}
# using the user define the cap function the capping method is used to handle the outliers
tidy_data$Birth_rate<-tidy_data$Birth_rate %>%  cap()
tidy_data$CHE<-tidy_data$CHE %>%  cap()
tidy_data$Death_rate<-tidy_data$Death_rate %>%  cap()
tidy_data$ANNI_PC<-tidy_data$ANNI_PC %>%  cap()
tidy_data$Total_population<-tidy_data$Total_population %>%  cap()
# Check for any more outliers after the capping method
tidy_data$Birth_rate %>%  boxplot(main="Birth Rate", ylab="Rate", col = "grey")
tidy_data$CHE %>%  boxplot(main="Current health expenditure (% of GDP)", ylab="Percentage of GDP", col = "grey")
tidy_data$Death_rate %>%  boxplot(main="Death Rate", ylab="Rate", col = "grey")
tidy_data$ANNI_PC %>%  boxplot(main="Adjusted net national income per capita (annual % growth)", ylab="Annual Percentage Growth", col = "grey")
tidy_data$Total_population %>%  boxplot(main="Total_population", ylab="Total_population", col = "grey")
# distribution plot before transfromation
hist(tidy_data$Total_population,main="Histogram of Total_population Before Transformation", breaks = 25)
# applying BoxCox transformation to Total_population
tidy_data$Total_population<- BoxCox(tidy_data$Total_population,lambda = "auto")
# checking the normal distribution after data transformation
hist(tidy_data$Total_population,main="Histogram of Total_population After Transformation", breaks = 25)
# check for remaining outliers
tidy_data$Total_population %>%  boxplot(main="Total_population", ylab="Total_population", col = "grey")
library(kableExtra)
